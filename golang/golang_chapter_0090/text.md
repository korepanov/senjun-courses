# Глава 9. Паника и восставление
## Паника
Компилятор языка Go проверяет все ошибки, которые может проверить, на этапе компиляции нашей программы. Однако существуют ошибки, которые могут быть выявлены только на этапе времени выполнения. Например, выход за границы массива или разыменование нулевого указателя. В этих случаях возникает аварийная ситуация или, говоря в терминах языка Go, *паника (panic)*. 

В этом случае выполнение пользовательской программы прекращается, выполняются все отложенные функции и происходит выход с печатью сообщения о том, в каком месте и по какой причине возникла паника. 

Панику вызывают самостоятельно, когда происходит некоторая недопустимая ситуация. Например, деление на нуль или достижение одного из условий, до которого программа не должна была дойти:

```go {.example_for_playground .example_for_playground_006}
func hello(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

func main() {
    grade := "bookeeper"

    if grade == "junior" || grade == "middle" || grade == "senior" {
        hello(grade)
    } else {
        panic(fmt.Sprintf("no such grade: %s", grade))
    }

}
```

**Паника вызывается тогда и только тогда, когда возникает ошибка в логике программы**. Так, если бы `grade` задавался с клавиатуры пользователем и не соответствовал одному из заранее заданных значений, то это ошибка ввода. В этом случае паника недопустима. Такая ошибка должна быть обработана другими средствами. Например, достаточно вывести ошибку на экран и попросить ввести `grade` повторно. Однако, если `grade` задан изначально программистом в коде, и по логике работы программы другое его значение невозможно, то смело вызывайте панику. В надежных программах паника не возникает никогда.

## Восстановление
Иногда в случае паники необходимо выполнить дополнительные действия. Например, если веб-сервер завершается с паникой, то он может отключить всех клиентов, а потом завершить работу, а не оставлять другие машины зависшими. Для этого используют ключевое слово `recover`:

```go {.example_for_playground .example_for_playground_007}
package main

import (
    "fmt"
    "time"
)

func startServer() {
    defer func() {
        if p := recover(); p != nil {
            fmt.Printf("Internal error: %s. Closing all connections...", p)
        }
    }()

    time.Sleep(1 * time.Millisecond) // server is working
    panic("not enough free disk space")
}

func main() {
    startServer()
}
```

Полное восстановление после паники не рекомендуется, потому что после паники состояние переменных пакета может оказаться непредсказуемым. Кроме того, такое восстановление может привести к тому, что критическая ошибка окажется попросту незамеченной.

## Резюме. 
1. Иногда в результате неправильной логики программного кода возникают аварийный ситуации. В таких случаях используют ключевое слово `panic`. 
2. В случае, когда необходимо произвести дополнительные действия во время паники, используют ключевое слово `recover`.
