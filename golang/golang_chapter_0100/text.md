# Глава 10. Строки

В Go строка `string` — это срез байтов, доступный только для чтения. Строки необязательно содержат читаемый для человека текст, однако чаще всего это так. Встроенная функция `len` возвращает количество байтов (**не символов!**) в строке. Так, программа ниже выведет на экран число `6`.

```go {.example_for_playground}
func main() {
	s := "hello!"
	fmt.Println(len(s))
}
```

Однако вот эта программа выведет на экран число `13`:

```go {.example_for_playground}
func main() {
	s := "привет!"
	fmt.Println(len(s))
}
```

Попытка обратиться к байту за пределами строки приведет к панике:

```go {.example_for_playground}
func main() {
	s := "привет!"
	fmt.Println(s[13])
}
```

Чтобы получить подстроку строки, поступают следующим образом:

```go {.example_for_playground}
func main() {
	s := "hello!"
	fmt.Println(s[0:4])
}
```

В результате будет напечатана подстрока строки `hello`, с нулевого (включительно) до четвертого (не включительно) байта.

Если задать левую границу больше правой, то возникает паника. В случае, когда не задана левая граница, то подставляется число `0`. Когда не задана правая граница, подставляется длина строки:

```go {.example_for_playground}
func main() {
	s := "hello!"
	fmt.Print(s[:4])
	fmt.Println(s[5:])
}
```

Строки сравниваемы. Сравниваются они байт за байтом, в лексиграфическом порядке. Так строка `abda` больше строки `abcd`, поскольку третий символ первой строки `d` имеет больший номер, чем третий символ второй строки `c`.

Напишите тело функции `isPalindrome`, которая проверяет, читается ли строка в обоих направлениях одинаково. Так, для слова `kayak` функция должна вернуть `true`, а для слова `blabla` — `false`. {.task_text}

```go {.task_source #golang_chapter_0100_task_0010}
package main

import "fmt"

func isPalindrome(s string) bool {
	// ваш код здесь
}

func main() {
	fmt.Println(isPalindrome("kayak"))
	fmt.Println(isPalindrome("blabla"))
}
```

Функцию `isPalindrome` удобно реализовать как рекурсивную функцию. {.task_hint}

```go {.task_answer}
package main

import "fmt"

func isPalindrome(s string) bool {
	if len(s) < 2 {
		return true
	}
	if s[0] != s[len(s)-1] {
		return false
	}
	return isPalindrome(s[1 : len(s)-1])
}

func main() {
	fmt.Println(isPalindrome("kayak"))
	fmt.Println(isPalindrome("blabla"))
}
```

Допустима конкатенация строк через символ «+»:

```go {.example_for_playground}
helloMessage := "hello"
name := "gopher"
fmt.Println(helloMessage + ", " + name + "!")
```

Однако для этого рекомендуется использовать возможности пакета `fmt`.

```go {.example_for_playground}
helloMesage := "hello"
name := "gopher"
fmt.Printf("%s, %s!\n", helloMesage, name)
```

В данном случае на места `%s` подставятся наши строки. Это делает код более читаемым.
Управляющая последовательность `\n` выполняет перенос строки. 

Чтобы не обрабатывать управляющие последовательности, а напечатать строку как есть, используют обратные одинарные кавычки:

```go {.example_for_playground}
	helloMesage := `Hello, gopher!
Here we use raw string. 
This won't work: \n`

	fmt.Println(helloMesage)
```

Переносы строки печатаются, тогда как управляющая последовательность `\n` выводится как есть. Иными словами, строка печатается буквально. 

Строки являются неизменяемыми. Даже если вы используете конкатенацию для строки, то на месте старой строки оказывается новая. Попытка изменить конкретный байт ведет к ошибке компиляции:


```go {.example_for_playground}
helloMessage := "hello"
helloMessage[1] = "b"
```

Такое решение было принято для увеличения быстродействия. Если строки неизменяемы, то они могут разделять общую память. Например, для получения подстроки никакой новой памяти выделено не будет. 

# Кодировки
Первоначально на все случаи жизни использовалась одна кодировка — **ASCII**. Она расшифровывается как American Standard Code for Information Interchange — Американский стандартный код для обмена информацией. В ней каждому символу поставлен в соответствие некоторый код. Всего — 128 символов. В ней собраны английские буквы, цифры, знаки пунктуации и управляющие символы.  

Для представления других символов была разработана кодировка **Unicode**. В ней содержится более 120 тыс. символов для различных языков. Номер символа Unicode представляется типом *int32*. В Go для этого типа существует синоним — *руна* `rune`.

Представлять каждый символ в виде 32-битного значения расточительно. Многие символы имеют номер, для которого можно было бы выделить в разы меньше памяти. Так, для всех символов ASCII было бы достаточно одного байта. Более аккуратным решением является кодировка переменной длины — **UTF-8**. Она изобретена двумя из создателей языка Go, Кеном Томпсоном и Робом Пайком.

UTF-8 представляется разумным решением, однако возникает проблема. Теперь длина текста в символах необязательно равна длине этого текста в байтах. Как же быть, когда необходимо знать длину текста в символах? Для этого используют `utf8.RuneCountInString`:

```go {.example_for_playground}
s := "привет!"
fmt.Println(utf8.RuneCountInString(s))
```

`utf8.RuneCountInString` вернет количество рун или символов Unicode, которые закодированы в строке.     
`utf8.DecodeRuneInString` возвращает руну и размер первого, входящего в строку, символа Unicode:
```go {.example_for_playground}
s := "привет!"
for i := 0; i < len(s); {
	r, size := utf8.DecodeRuneInString(s[i:])
	fmt.Printf("%d:\t%c\n", r, r)
	i += size
}
```
Здесь мы печатаем код символа и сам символ.  
Чтобы превратить срез из рун в строку UTF-8, достаточно преобразовать его через `string`:

```go {.example_for_playground}
r := []rune{1087, 1088, 1080, 1074, 1077, 1090, 33}
fmt.Println(string(r))
```
В случае некорректного кода генерируется символ, который обычно выглядит как белый вопросительный знак в черном ромбе:

```go {.example_for_playground}
fmt.Println(string(1234567))
```
