# Глава 10. Строки

В Go строка `string` — это срез байтов, доступный только для чтения. Строки необязательно содержат читаемый для человека текст, однако чаще всего это так. Встроенная функция `len` возвращает количество байтов (**не символов!**) в строке. Так, программа ниже выведет на экран число `6`.

```go {.example_for_playground .example_for_playground_001}
func main() {
	s := "hello!"
	fmt.Println(len(s))
}
```

Однако вот эта программа выведет на экран число `13`:

```go {.example_for_playground .example_for_playground_002}
func main() {
	s := "привет!"
	fmt.Println(len(s))
}
```

Попытка обратиться к байту за пределами строки приведет к панике:

```go {.example_for_playground .example_for_playground_003}
func main() {
	s := "привет!"
	fmt.Println(s[13])
}
```

Чтобы получить подстроку строки, поступают следующим образом:

```go {.example_for_playground .example_for_playground_004}
func main() {
	s := "hello!"
	fmt.Println(s[0:4])
}
```

В результате будет напечатана подстрока строки `hello`, с нулевого (включительно) до четвертого (не включительно) байта.

Если задать левую границу больше правой, то возникает паника. В случае, когда не задана левая граница, то подставляется число `0`. Когда не задана правая граница, подставляется длина строки:

```go {.example_for_playground .example_for_playground_004}
func main() {
	s := "hello!"
	fmt.Print(s[:4])
	fmt.Println(s[5:])
}
```

Допустима конкатенация строк черз символ «+»:

```go {.example_for_playground .example_for_playground_005}
helloMessage := "hello"
name := "gopher"
fmt.Println(helloMessage + ", " + name + "!")
```

Однако для этого рекоменуется использовать возможности пакета `fmt`.

```go {.example_for_playground .example_for_playground_006}
helloMesage := "hello"
name := "gopher"
fmt.Printf("%s, %s!\n", helloMesage, name)
```

В данном случае на места `%s` подставятся наши строки. Это делает код более читаемым.
Управляющая последовательнось `\n` выполняет перенос строки. 

Чтобы не обрабатывать управляющие последовательности, а напечатать строку как есть, используют обратные одинарные кавычки:

```go
	helloMesage := `Hello, gopher!
Here we use raw string. 
This won't work: \n`

	fmt.Println(helloMesage)
```

Переносы строки печатаются, тогда как управляющая последовательность `\n` выводится как есть. Иными словами, строка печатается буквально. 

Строки являются неизмняемыми. Даже если вы используете конкатенацию для строки, то на месте старой строки оказывается новая. Попытка изменить конкретный байт ведет к ошибке компиляции:


```go {.example_for_playground .example_for_playground_007}
helloMessage := "hello"
helloMessage[1] = "b"
```

Такое решение было принято для увеличения быстродействия. Если строки неизменяемы, то они могут разделять общую память. Например, для получения подстроки никакой новой памяти выделено не будет. 


