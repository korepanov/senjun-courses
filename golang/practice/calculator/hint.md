## Подход к выполнению практики

В этой подсказке приводятся указания по способу выполнения практики, описанному в разделе «Теория». Согласно этому способу вычисление алгебраического выражения состоит из трех этапов: токенизация, перевод в постфиксную форму, вычисление выражения в постфиксной форме.

## Представление токенов

Каждый токен можно представить в виде словаря с двумя обязательными ключами: `type` — тип токена (число, скобка и т.д.); `value` — значение токена. Тогда алгебраическое выражение представляется в виде списка токенов.


Например, строка с выражением `9.5-(1+3)` превращается в список:

```
[
    {
        "type": "operand",
        "value": 9.5
    },
    {
        "type": "operator",
        "value": "-"
    },
    {
        "type": "parenthesis"
        "value": "("
    },
    {
        "type": "operand",
        "value": 1
    },
    {
        "type": "operator",
        "value": "+"
    },
    {
        "type": "operand",
        "value": 3
    },
    {
        "type": "parenthesis",
        "value": ")"
    }
]
```

Для того чтобы по исходному выражению получить список токенов, необходимо составить конечный автомат.

## Представление конечного автомата

КА для парсинга выражения на токены можно представить в виде словаря словарей.

Ключи словаря верхнего уровня — обозначения для классов (категорий) символов. Например, `"digit"` для цифр, `"point"` для точки, `"parenthesis"` для скобок, `"operator"` для математических операций. Значение по данному ключу — тоже словарь.

Ключи в этом вложенном словаре  — обозначения вариантов текущего состояния. А значения — кортежи из пары элементов: обозначения нового состояния и функции, которую требуется выполнить при переходе между состояниями. Как вы помните, в питоне функции могут быть присвоены переменной (в том числе элементу кортежа).

Вот как может выглядеть КА в виде словаря словарей.

```python
{
    # Символ
    POINT: {
        # Текущее состояние        Новое состояние         Действие
        NEW_TOKEN:              (NUMBER_FRACTIONAL_PART, start_accumulating_number),
        NUMBER_INTEGER_PART:    (NUMBER_FRACTIONAL_PART, accumulate_number),
        NUMBER_FRACTIONAL_PART: (ERROR,                  None),
        ...
    },
    ...
}
```

Здесь `POINT` — константа, обозначающая, что мы обрабатываем символ точки. `NEW_TOKEN` — константа, обозначающая состояние обработки односимвольного токена, `start_accumulating_number` и `accumulate_number` — функции, вызываемые *при переходе* к накоплению числа и *в процессе* накопления числа.

Допустим, конечный автомат представлен в виде словаря с именем `FSM` (finite-state machine). Тогда переключение между состояниями `cur_state` и `next_state` будет выглядеть так:

```python
data = FSM[cur_symbol][cur_state]

next_state = data[0]
action = data[1]
```

Здесь `cur_symbol` — класс обрабатываемого символа. Для его получения можно завести отдельную функцию, которая по символу возвращает обозначение его класса.


## Что использовать для реализации стека

Алгоритмы для перевода инфиксной формы в постфиксную и расчета выражения в постфиксной форме задействуют структуру данных стек. В качестве стека вы можете использовать обычный список `list`. Вам пригодятся методы списка `append()` и `pop()`, а также встроенная функция `len()` для определения количества элементов.