# Практика. Калькулятор алгебраических выражений

## Описание проекта

Необходимо реализовать функцию `calc()`. Она принимает единственный аргумент — строку. Это алгебраическое выражение, состоящее из чисел, символов математических операций и скобок. Например:

```
81.0-(2.5+1)/3
```

Если в числе есть дробная часть, то она отделяется точкой: `71.45`. Допустимы числа с опущенной целой или дробной частью: `.5`, `22.`. В таких случаях опущенная часть считается равной нулю.

Математическими операциями могут быть: сумма `+`, разность `-`, произведение `*`, деление `/`.

Приоритет операций умножения и деления выше, чем сложения и вычитания.

Все перечисленные операции [левоассоциативны:](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D1%91%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9) при отсутствии скобок выражение с операциями одинакового приоритета вычисляется слева направо. Если бы среди операций были правоассоциативные, это бы немного усложнило код решения.

Функция `calc()` должна вернуть вещественное число — результат вычисленного выражения. Либо ошибку, отличную от `nil`, если выражение составлено некорректно. Считаем, что входных данных, приводящих к делению на ноль, не будет.

## Примеры

Корректно составленное выражение:

```
(1-2.8)*3
```

Значение функции `calc()`:

```
-5.4
```

Выражение с пропущенной закрывающей скобкой:

```
(16/2*3
```

Выражение с недопустимыми символами (пробелами, буквами `a` и `b`):

```
5*a + b
```

Выражение с нарушенной последовательностью математических операций:

```
10++2
```

Выражение, в котором неправильно записаны числа:

```
1.2.3-..5
```


Так как в этих четырех выражениях есть ошибки, функция `calc()` для них должна вернуть ошибку, отличную от `nil`.

## Тестирование

Вы можете дописать свои варианты алгебраических выражений в файле `main.go` и проверить, как ведет себя функция `calc()` на различных входных данных. Чтобы скомпилировать и запустить программу с точкой входа в `main.go`, нажмите кнопку «Запустить».

Когда функция `calc()` будет готова к тестированию, нажмите кнопку «Отправить на проверку». По ней запустятся юнит-тесты из файла `main_test.go`. В этом же файле можно посмотреть ожидаемые значения функции для набора алгебраических выражений.

## Теория

Калькулятор алгебраических выражений — классическое задание, которое дают студентам, обучающимся программированию. Поэтому если вы знаете, как выполнить проект, можете сразу перейти к написанию кода и пропустить этот раздел. Здесь будет рассмотрен один из подходов к решению.

## Алгоритм вычисления выражения

Декомпозируем вычисление алгебраического выражения на три подзадачи:
- токенизация,
- синтаксический анализ,
- вычисление выражения.

### 1. Токенизация

**Токенизация** — лексический анализ строки, разбиение ее на токены. В контексте нашей задачи токен — это неделимая составляющая арифметического выражения: математическая операция, число (операнд), скобка.

Входные данные для токенизации — строка с выражением. Например:

```
9.5-(1+3)
```

На выходе — список токенов:

```
┌───────┐┌────────┐┌───────┐┌───────┐┌────────┐┌───────┐┌───────┐
│  9.5  ││    -   ││   (   ││  1    ││    +   ││   3   ││  )    │ 
└───────┘└────────┘└───────┘└───────┘└────────┘└───────┘└───────┘
 число    операция  скобка   число    операция  число    скобка
```

### 2. Синтаксический анализ

**Синтаксический анализ** заключается в том, чтобы выявить те отношения, в которых токены находятся друг относительно друга. Результатом синтаксического анализа является **AST**. AST расшифровывается как **abstract syntax tree**, **абстрактное синтаксическое дерево**. Листьями AST являются операнды. Родительские узлы — операции. Для выражения `9.5-(1+3)` AST выглядит следующим образом:

```
start
   └─ -
      ├─ 9.5
      └─ +
         ├─ 1
         └─ 3
```
Здесь для наглядности в качестве корня используется метка `start`. Однако это необязательно.  

Для генерации AST рекомендуется воспользоваться следующей **грамматикой**:

```
expression = term | expression "+" term | expression "-" term
term = factor | term "*" factor | term "/" factor
factor = number | "(" expression ")"
```

Основываясь на этой грамматике, необходимо определить, представлено ли выражение в форме `expression`. 

Символ `|` можно читать как логическое `ИЛИ`. Таким образом, по первой строчке можно заключить следующее. Если выражение представлено в форме `term`, `expression "+" term`, либо `expression "-" term`, то это выражение в форме `expression`. Символы, указанные в кавычках, должны стоять в выражении буквально. Аналогично для двух других строк. Слово `number` означает любое число.

Предполагая, что вам дали на вход правильное выражение, разберите его по этой грамматике. Попутно сгенерируйте AST. 

Например, пусть выражение `9.5-(1+3)` в форме `expression`. Тогда оно должно быть в одной из трех форм, представленных грамматикой. Нужно проверить каждую из них. 

**Шаг 1**. Как мы видим, выражение в форме `expression "-" term`. Здесь в качестве `expression` выступает `9.5`, а в качестве `term` — `(1+3)`. Поэтому мы должны сгенировать `AST` с вершиной `-` и опернадами: `expression` и `term`, каждый из которых мы разберем в следующих шагах.   

**Шаг 2**. Операнд `expression` представляет собой `term`, который является `factor`. Он в свою очередь — `number`. Возвращаем `9.5` в качестве листа дерева, полученного на первом шаге.   

**Шаг 3**. Операнл `term`, равный `(1+3)`, представляет собой `factor` в виде `"(" expression ")`. Необходимо разобрать выражение `expression` и вернуть в качестве листа дерева полученное поддерево.      

Если выражение невозможно разобрать по этой грамматике, то оно некорректное. В этом случае верните ошибку. 

### 3. Вычисление выражения в постфиксной форме

На предыдущем этапе был получен список токенов алгебраического выражения в постфиксной форме. Осталось получить результат этого выражения. Воспользуемся [стековым алгоритмом](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BD%D0%B0_%D1%81%D1%82%D0%B5%D0%BA%D0%B5) вычисления выражения в постфиксной форме:

В цикле проходим по токенам:

— Если токен — число, то он помещается в стек.

— Если токен — математическая операция, то она выполняется. Для этого извлекается необходимое количество операндов из стека, к ним применяется операция, и результат вычисления помещается в стек. Важно помнить, что значение на вершине стека — это правый операнд, а не левый.

После выполнения этого цикла в стеке должно остаться единственное значение. Это и есть результат алгебраического выражения.